<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Allison C Fialkowski" />

<meta name="date" content="2017-12-12" />

<title>Comparison of Correlation Methods 1 and 2</title>






<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Comparison of Correlation Methods 1 and 2</h1>
<h4 class="author"><em>Allison C Fialkowski</em></h4>
<h4 class="date"><em>2017-12-12</em></h4>



<p>There are two simulation pathways which differ primarily according to the calculation of the intermediate correlations involving count variables. The simulation function <code>corrvar</code> for correlation method 1 calls the function <code>intercorr</code>. The simulation function <code>corrvar2</code> for correlation method 2 calls the function <code>intercorr2</code>. Both of these call additional auxiliary functions as needed. The <em>ordering of the variables</em> in the target correlation matrix <code>rho</code> must be 1st ordinal, 2nd continuous non-mixture, 3rd components of continuous mixture variables, 4th regular Poisson, 5th zero-inflated Poisson, 6th regular NB, and 7th zero-inflated NB. Note that the target correlations are specified in terms of the correlations with components of continuous mixture variables. The correlation between components of the same mixture variable should be set to <span class="math inline">\(0\)</span> by the user. Sometimes this necessitates the conversion of the intermediate correlation matrix <code>Sigma</code> to the nearest positive-definite matrix. This is done within the simulation functions by specifying <code>use.nearPD = TRUE</code>. <span class="citation">Higham (2002)</span>’s algorithm is executed with the <code>Matrix::nearPD</code> function <span class="citation">(Bates and Maechler 2017)</span>. Otherwise, negative eigenvalues are replaced with <span class="math inline">\(0\)</span>. Some code has been modified from the <strong>SimMultiCorrData</strong> package <span class="citation">(Fialkowski 2017)</span>.</p>
<div id="methods-used-in-both-pathways" class="section level2">
<h2>Methods Used in Both Pathways:</h2>
<p>First, the intermediate correlation calculations which are equivalent in the two pathways will be discussed by variable type.</p>
<div id="ordinal-variables" class="section level3">
<h3>Ordinal Variables:</h3>
<p>If both variables are <strong>binary</strong>, the method of <span class="citation">Demirtas, Hedeker, and Mermelstein (2012)</span> is used to find the <em>tetrachoric correlation</em> (code adapted from <span class="citation">Inan and Demirtas (2016)</span>’s <code>BinNonNor::Tetra.Corr.BB</code>). The tetrachoric correlation is an estimate of the binary correlation measured on a continuous scale. The assumptions are that the binary variables arise from latent normal variables, and the actual trait is continuous and not discrete. This method is based on <span class="citation">Emrich and Piedmonte (1991)</span>’s work, in which the joint binary distribution is determined from the third and higher moments of a multivariate normal distribution:</p>
<p>Let <span class="math inline">\(Y_{1}\)</span> and <span class="math inline">\(Y_{2}\)</span> be binary variables with <span class="math inline">\(E[Y_{1}] = Pr(Y_{1} = 1) = p_{1}\)</span>, <span class="math inline">\(E[Y_{2}] = Pr(Y_{2} = 1) = p_{2}\)</span>, and correlation <span class="math inline">\(\rho_{y1y2}\)</span>. Note here that <span class="math inline">\(p_1 = 1 -\)</span> <code>marginal[[1]][1]</code> and <span class="math inline">\(p_2 = 1 -\)</span> <code>marginal[[2]][1]</code> so that the user-supplied probabilities are associated with the lower support value.</p>
<p>Let the standard bivariate normal CDF and PDF be given by: <span class="math display">\[
\begin{aligned}
\Phi[x_{1}, x_{2}, \rho_{x1x2}] &amp;= \int_{-\infty}^{x_{1}} \int_{-\infty}^{x_{2}} f(z_{1}, z_{2}, \rho_{x1x2})\ dz_{1} dz_{2} \\
f(z_{1}, z_{2}, \rho_{x1x2}) &amp;= [2\pi\sqrt{1 - \rho_{x1x2}^2}]^{-1} * exp[-0.5(z_{1}^2 - 2\rho_{x1x2}z_{1}z_{2} + z_{2}^2)/(1 - \rho_{x1x2}^2)].
\end{aligned}
\]</span> Then solving the equation <span class="math display">\[\Phi[z(p_{1}), z(p_{2}), \rho_{x1x2}] = \rho_{y1y2}\sqrt{p_{1}(1 - p_{1})p_{2}(1 - p_{2})} + p_{1}p_{2}\]</span> for <span class="math inline">\(\rho_{x1x2}\)</span> gives the intermediate correlation of the standard normal variables needed to generate binary variables with correlation <span class="math inline">\(\rho_{y1y2}\)</span>. Here <span class="math inline">\(z(p)\)</span> indicates the <span class="math inline">\(p^{th}\)</span> quantile of the standard normal distribution.</p>
<p>To generate the binary variables from the standard normal variables, set <span class="math inline">\(Y_{1} = 1\)</span> if <span class="math inline">\(Z_{1} \le z(p_{1})\)</span> and <span class="math inline">\(Y_{1} = 0\)</span> otherwise. Similarly, set <span class="math inline">\(Y_{2} = 1\)</span> if <span class="math inline">\(Z_{2} \le z(p_{2})\)</span> and <span class="math inline">\(Y_{2} = 0\)</span> otherwise. This ensures: <span class="math display">\[
\begin{aligned}
E[Y_{1}] &amp;= Pr(Y_{1} = 1) = Pr(Z_{1} \le z(p_{1})) = p_{1}, \\
E[Y_{2}] &amp;= Pr(Y_{2} = 1) = Pr(Z_{2} \le z(p_{2})) = p_{2}, \\
Cov(Y_{1}, Y_{2}) &amp;= Pr(Y_{1} = 1, Y_{2} = 1) - p_{1}p_{2} \\
&amp;= Pr(Z_{1} \le z(p_{1}), Z_{2} \le z(p_{2})) - p_{1}p_{2} \\
&amp;= \Phi[z(p_{1}), z(p_{2}), \rho_{x1x2}] - p_{1}p_{2} \\
&amp;= \rho_{y1y2}\sqrt{p_{1}(1 - p_{1})p_{2}(1 - p_{2})}, \\
Cor(Y_{1}, Y_{2}) &amp;= Cov(Y_{1}, Y_{2})/\sqrt{p_{1}(1 - p_{1})p_{2}(1 - p_{2})} = \rho_{y1y2}.
\end{aligned}
\]</span></p>
<p>For <strong>binary-ordinal</strong> or <strong>ordinal</strong> pairs, <code>ord_norm</code> is called. The algorithm to simulate <code>k_cat</code> ordinal random variables is as follows:</p>
<ol style="list-style-type: decimal">
<li><p>Check that the target correlation matrix <code>rho0</code> for the ordinal variables is positive-definite. If not, stop with an error.</p></li>
<li><p>If a <code>support</code> is not provided, create the default of <span class="math inline">\(1, ..., r\)</span> for an ordinal variable with <span class="math inline">\(r\)</span> categories.</p></li>
<li><p>Use the <code>norm_ord</code> function to calculate the initial correlation of the ordinal variables (<code>rhoordold</code>) formed by discretizing <code>k_cat</code> random normal variates with correlation matrix set equal to <code>rho0</code>, using the cumulative probabilities supplied in <code>marginal</code> and the corresponding normal quantiles.</p></li>
<li><p>Let <code>rho</code> be the intermediate normal correlation updated in each iteration, <code>rhoord</code> be the ordinal correlation calculated in each iteration, <code>rhoold</code> be the intermediate correlation from the previous iteration, <code>it</code> be the iteration number, <code>maxit</code> be the user-specified maximum iteration number, and <code>epsilon</code> be the user-specified maximum pairwise correlation error. For each variable pair, execute the following:</p></li>
</ol>
<ol style="list-style-type: lower-alpha">
<li>If <code>rho0</code> <span class="math inline">\(= 0\)</span>, set <code>rho</code> <span class="math inline">\(= 0\)</span>.<br />
</li>
<li>While the absolute error between <code>rhoord</code> and <code>rho0</code> is greater than <code>epsilon</code> and <code>it</code> is less than <code>maxit</code>:
<ol style="list-style-type: lower-roman">
<li>If <code>rho0 * (rho0/rhoord)</code> <span class="math inline">\(\leq -1\)</span>, then: <code>rho = rhoold * (1 + 0.1 * (1 - rhoold) * -sign(rho0 - rhoord))</code>.<br />
</li>
<li>If <code>rho0 * (rho0/rhoord)</code> <span class="math inline">\(\geq 1\)</span>, then: <code>rho = rhoold * (1 + 0.1 * (1 - rhoold) * sign(rho0 - rhoord))</code>.<br />
</li>
<li>Otherwise, <code>rho = rhoold * (rho0/rhoord)</code>.<br />
</li>
<li>If <code>rho</code> <span class="math inline">\(&gt; 1\)</span>, set <code>rho</code> <span class="math inline">\(= 1\)</span>. If <code>rho</code> <span class="math inline">\(&lt; -1\)</span>, set <code>rho</code> <span class="math inline">\(= -1\)</span>.</li>
<li>Calculate <code>rhoord</code> using <code>norm_ord</code> and the 2$$2 correlation matrix formed by <code>rho</code>.<br />
</li>
<li>Set <code>rhoold = rho</code> and increase <code>it</code> by 1.<br />
</li>
</ol></li>
<li>Store the number of iterations in the matrix <code>niter</code>.</li>
</ol>
<ol start="5" style="list-style-type: decimal">
<li>Return the final intermediate correlation matrix <code>SigmaC = rho</code> for the random normal variables. Discretize these to produce ordinal variables with the desired correlation matrix.</li>
</ol>
</div>
<div id="continuous-variables" class="section level3">
<h3>Continuous Variables:</h3>
<p>Correlations are computed pairwise. The function <code>intercorr_cont</code> is called for each pair. It uses the equations derived by <span class="citation">Headrick and Sawilowsky (1999)</span> for the third-order and <span class="citation">Headrick (2002)</span> for the fifth-order power method transformation (PMT).</p>
<p>For two continuous variables <span class="math inline">\(Y_i\)</span> and <span class="math inline">\(Y_j\)</span> generated using <span class="citation">Headrick (2002)</span>’s fifth-order PMT, the intermediate normal correlation <span class="math inline">\(\rho_{{Z}_{i}{Z}_{j}}\)</span> required to obtain the target correlation <span class="math inline">\(\rho_{{Y}_{i}{Y}_{j}}\)</span> is the solution to the following:<br />
<span class="math display">\[
\begin{aligned}
    {\rho}_{{Y}_{i}{Y}_{j}} &amp;= 3{c}_{{4}_{i}}{c}_{{0}_{j}}+3{c}_{{4}_{i}}{c}_{{2}_{j}}+9{c}_{{4}_{i}}{c}_{{4}_{j}}+{c}_{{0}_{i}}({c}_{{0}_{j}}+{c}_{{2}_{j}}+3{c}_{{4}_{j}})+{c}_{{1}_{i}}{c}_{{1}_{j}}{\rho}_{{Z}_{i}{Z}_{j}}+3{c}_{{3}_{i}}{c}_{{1}_{j}}{\rho}_{{Z}_{i}{Z}_{j}}  \\
        &amp; +15{c}_{{5}_{i}}{c}_{{1}_{j}}{\rho}_{{Z}_{i}{Z}_{j}}+3{c}_{{1}_{i}}{c}_{{1}_{j}}{\rho}_{{Z}_{i}{Z}_{j}}+9{c}_{{3}_{i}}{c}_{{3}_{j}}{\rho}_{{Z}_{i}{Z}_{j}}+45{c}_{{5}_{i}}{c}_{{3}_{j}}{\rho}_{{Z}_{i}{Z}_{j}}+15{c}_{{1}_{i}}{c}_{{5}_{j}}{\rho}_{{Z}_{i}{Z}_{j}}  \\
        &amp; +45{c}_{{3}_{i}}{c}_{{5}_{j}}{\rho}_{{Z}_{i}{Z}_{j}}+225{c}_{{5}_{i}}{c}_{{5}_{j}}{\rho}_{{Z}_{i}{Z}_{j}}+12{c}_{{4}_{i}}{c}_{{2}_{j}}{{\rho}_{{Z}_{i}{Z}_{j}}}^{2}+72{c}_{{4}_{i}}{c}_{{4}_{j}}{{\rho}_{{Z}_{i}{Z}_{j}}}^{2}+6{c}_{{3}_{i}}{c}_{{3}_{j}}{{\rho}_{{Z}_{i}{Z}_{j}}}^{3} \\
        &amp; +60{c}_{{5}_{i}}{c}_{{3}_{j}}{{\rho}_{{Z}_{i}{Z}_{j}}}^{3}+60{c}_{{3}_{i}}{c}_{{5}_{j}}{{\rho}_{{Z}_{i}{Z}_{j}}}^{3}+600{c}_{{5}_{i}}{c}_{{5}_{j}}{{\rho}_{{Z}_{i}{Z}_{j}}}^{3}+24{c}_{{4}_{i}}{c}_{{4}_{j}}{{\rho}_{{Z}_{i}{Z}_{j}}}^{4}+120{c}_{{5}_{i}}{c}_{{5}_{j}}{{\rho}_{{Z}_{i}{Z}_{j}}}^{5} \\
        &amp; +{c}_{{2}_{i}}({c}_{{0}_{j}}+{c}_{{2}_{j}}+3{c}_{{4}_{j}}+2{c}_{{2}_{j}}{{\rho}_{{Z}_{i}{Z}_{j}}}^{2}+12{c}_{{4}_{j}}{{\rho}_{{Z}_{i}{Z}_{j}}}^{2}).
\end{aligned}
\]</span></p>
<p>For two continuous variables <span class="math inline">\(Y_i\)</span> and <span class="math inline">\(Y_j\)</span> generated using <span class="citation">Fleishman (1978)</span>’s third-order PMT, the intermediate normal correlation <span class="math inline">\(\rho_{{Z}_{i}{Z}_{j}}\)</span> required to obtain the target correlation <span class="math inline">\(\rho_{{Y}_{i}{Y}_{j}}\)</span> is the solution to the following:<br />
<span class="math display">\[
\begin{aligned}
    {\rho}_{{Y}_{i}{Y}_{j}} &amp;= \rho_{{Z}_{i}{Z}_{j}}(c_{1_{i}}c_{1_{j}}+3c_{1_{j}}c_{3_{i}}+3c_{1_{i}}c_{3_{j}}+9c_{3_{i}}c_{3_{j}}+2c_{0_{i}}c_{0_{j}}\rho_{{Z}_{i}{Z}_{j}}+6c_{3_{i}}c_{3_{j}}\rho_{{Z}_{i}{Z}_{j}}^2).
\end{aligned}
\]</span></p>
</div>
<div id="continuous-ordinal-pairs" class="section level3">
<h3>Continuous-Ordinal Pairs:</h3>
<p>The function <code>SimMultiCorrData::findintercorr_cont_cat</code> is called to calculate the intermediate normal correlations. The intermediate correlation between <span class="math inline">\(Z_1\)</span> and <span class="math inline">\(Z_2\)</span> (where <span class="math inline">\(Z_1\)</span> is the standard normal variable transformed using <span class="citation">Headrick (2002)</span>’s fifth-order or <span class="citation">Fleishman (1978)</span>’s third-order PMT to produce a continuous variable <span class="math inline">\(Y_1\)</span>, and <span class="math inline">\(Z_2\)</span> is the standard normal variable discretized to produce an ordinal variable <span class="math inline">\(Y_2\)</span>) is calculated by dividing the target correlation by a correction factor. The correction factor is the product of the point-polyserial correlation between <span class="math inline">\(Y_2\)</span> and <span class="math inline">\(Z_2\)</span> (described in <span class="citation">Olsson, Drasgow, and Dorans (1982)</span>): <span class="math display">\[{{\rho}}_{{Y}_{2}{Z}_{2}} = \frac{{\rho}_{{Z}_{2}{Z}_{2}}}{{\sigma}_{{Y}_{2}}} \sum_{j=1}^{r-1}\phi({\tau}_{j})({y}_{{2}_{j+1}}-{y}_{{2}_{j}}) = \frac{1}{{\sigma}_{{Y}_{2}}} \sum_{j=1}^{r-1}\phi({\tau}_{j})({y}_{{2}_{j+1}}-{y}_{{2}_{j}}),\]</span> and the power method correlation between <span class="math inline">\(Y_1\)</span> and <span class="math inline">\(Z_1\)</span> (described in <span class="citation">Headrick and Kowalchuk (2007)</span>): <span class="math display">\[{c}_{1}+3{c}_{3}+15{c}_{5}.\]</span> The constant <span class="math inline">\(c_5 = 0\)</span> for the third-order PMT. Then the intermediate normal correlation <span class="math inline">\(\rho_{{Z}_{1}{Z}_{2}}\)</span> required to obtain the target correlation <span class="math inline">\(\rho_{{Y}_{1}{Y}_{2}}\)</span> is given by: <span class="math display">\[
\begin{aligned}
{\rho}_{{Z}_{1}{Z}_{2}} &amp;= \frac{{\rho}_{{Y}_{1}{Y}_{2}}{\sigma}_{{Y}_{2}}}{({c}_{1}+3{c}_{3}+15{c}_{5})\ \sum_{j=1}^{r-1}\phi({\tau}_{j})({y}_{{2}_{j+1}}-{y}_{{2}_{j}})} \\
    &amp;= \frac{{\rho}_{{Y}_{1}{Y}_{2}}{\sigma}_{{Y}_{2}}}{({c}_{1}+3{c}_{3}+15{c}_{5})\ \sum_{j=1}^{r-1}\phi(\Phi^{-1}(\sum_{i=1}^{j}{p}_{j}))({y}_{{2}_{j+1}}-{y}_{{2}_{j}})}.
\end{aligned}
\]</span> Here, <span class="math inline">\(\phi\)</span> is the standard normal PDF, <span class="math inline">\({\sigma}_{{Y}_{2}}\)</span> is the standard deviation of the ordinal variable, and <span class="math inline">\({\mu}_{{Y}_{2}}\)</span> is its expected value: <span class="math display">\[{\sigma}_{{Y}_{2}} = \sqrt{\sum_{j=1}^{r}{y}_{{2}_{j}}^2{p}_{j} - {\mu}_{{Y}_{2}}^2},\ \ \ {\mu}_{{Y}_{2}} = \sum_{j=1}^{r}{y}_{{2}_{j}}{p}_{j}.\]</span></p>
<p>Now the two methods will be contrasted.</p>
</div>
</div>
<div id="overview-of-correlation-method-1" class="section level2">
<h2>Overview of Correlation Method 1:</h2>
<p>The intermediate correlations used in correlation method 1 are more simulation based than those in correlation method 2, which means that accuracy increases with sample size and the number of repetitions. Specifying the seed allows for reproducibility. In addition, method 1 differs from method 2 in the following ways:</p>
<ol style="list-style-type: decimal">
<li><p>The <strong>count variable</strong> correlations extend the method of <span class="citation">Yahav and Shmueli (2012)</span>. The intermediate correlation between <span class="math inline">\(Z_1\)</span> and <span class="math inline">\(Z_2\)</span> (the standard normal variables used to generate the count variables <span class="math inline">\(Y_1\)</span> and <span class="math inline">\(Y_2\)</span> via the inverse CDF method) is calculated using a logarithmic transformation of the target correlation. First, the upper and lower Frechet-Hoeffding bounds (mincor, maxcor) on <span class="math inline">\({\rho}_{{Y}_{1}{Y}_{2}}\)</span> are simulated <span class="citation">(Fréchet 1957; Hoeffding 1994)</span>. See the <a href="corr_bounds.html">Calculation of Correlation Boundaries</a> vignette for details on the Frechet-Hoeffding correlation boundaries. The intermediate correlation <span class="math inline">\({\rho}_{{Z}_{1}{Z}_{2}}\)</span> is found as follows: <span class="math display">\[{\rho}_{{Z}_{1}{Z}_{2}} = \frac{1}{b} * log \Bigg(\frac{{\rho}_{{Y}_{1}{Y}_{2}} - c}{a} \Bigg),\]</span> where <span class="math display">\[a = -\frac{maxcor * mincor}{maxcor + mincor},\ \ \ b = log \Bigg(\frac{maxcor + a}{a} \Bigg),\ \ \ c = -a.\]</span></p>
<ol style="list-style-type: lower-alpha">
<li><em>Poisson variables:</em> <code>intercorr_pois</code> is called to calculate the intermediate correlations for all variables.</li>
<li><em>Negative Binomial variables:</em> <code>intercorr_nb</code> is called to calculate the intermediate correlations for all variables.</li>
</ol></li>
</ol>
<p>This method becomes less accurate as the variable mean gets closer to zero. The distribution functions are taken from the <strong>VGAM</strong> package <span class="citation">(Yee 2017)</span>.</p>
<ol style="list-style-type: decimal">
<li><p>The <strong>ordinal - count variable</strong> correlations are based on an extension of the method of <span class="citation">Amatya and Demirtas (2015)</span>, in which the correlation correction factor is the product of the upper Frechet-Hoeffding bound on the correlation between the count variable and the normal variable used to generate it and a simulated upper bound on the correlation between an ordinal variable and the normal variable used to generate it <span class="citation">(Demirtas and Hedeker 2011)</span>. The intermediate correlations are the ratio of the target correlations to the correction factors.</p>
<ol style="list-style-type: lower-alpha">
<li><em>Poisson variables:</em> <code>intercorr_cat_pois</code> is called to calculate the intermediate correlations for all variables.</li>
<li><em>Negative Binomial variables:</em> <code>intercorr_cat_nb</code> is called to calculate the intermediate correlations for all variables.</li>
</ol></li>
<li><p>The <strong>continuous - count variable</strong> correlations are based on an extension of the methods of <span class="citation">Amatya and Demirtas (2015)</span> and <span class="citation">Demirtas, Hedeker, and Mermelstein (2012)</span>, in which the correlation correction factor is the product of the upper Frechet-Hoeffding bound on the correlation between the count variable and the normal variable used to generate it and the power method correlation between the continuous variable and the normal variable used to generate it <span class="citation">(Headrick and Kowalchuk 2007)</span>. The intermediate correlations are the ratio of the target correlations to the correction factors.</p>
<ol style="list-style-type: lower-alpha">
<li><em>Poisson variables:</em> <code>intercorr_cont_pois</code> is called to calculate the intermediate correlations for all variables.</li>
<li><em>Negative Binomial variables:</em> <code>intercorr_cont_nb</code> is called to calculate the intermediate correlations for all variables.</li>
</ol></li>
</ol>
<div id="simulation-process" class="section level3">
<h3>Simulation Process:</h3>
<p>The simulation functions do not perform checks on the distribution parameters or target correlation matrix <code>rho</code>. This should be done first using <code>validpar</code> to ensure they are of the correct dimension, format, and/or sign. The function <code>validcorr</code> should also be used to check if <code>rho</code> is within the feasible bounds and determine the lower and upper correlation limits. Summaries of simulated variables can be obtained using <code>summary_var</code>.</p>
<p>The algorithm used in the simulation function <code>corrvar</code> that employs correlation method 1 is as follows:</p>
<ol style="list-style-type: decimal">
<li><p>If continuous variables are desired, the standardized cumulants are checked to see if there are any repeated distributions (i.e., if the user wishes to simulate two  variables). These are noted so that the constants are calculated only once.</p></li>
<li><p>The constants are calculated for the continuous non-mixture variables and components of continuous mixture variables using <code>SimMultiCorrData::find_constants</code>. If no solutions are found that generate valid power method PDF’s, the function will return constants that produce invalid PDF’s (or a stop error if no solutions can be found). Errors regarding constant calculation are the most probable cause of function failure. Possible solutions include changing the seed or using a list of sixth cumulant correction values (if <code>method</code> = “Polynomial”).</p></li>
<li><p>The default support is created for the ordinal variables (if no support is provided).</p></li>
<li><p>The intermediate correlation matrix <code>Sigma</code> is calculated using <code>intercorr</code>. Note that this will return a matrix that is not positive-definite. If so and <code>use.nearPD = TRUE</code>, the algorithm of <span class="citation">Higham (2002)</span> is used (see <code>Matrix::nearPD</code>) to produce the nearest positive-definite matrix and a message is given. Otherwise, negative eigenvalues are replaced with <span class="math inline">\(0\)</span>.</p></li>
<li><p><code>k &lt;- k_cat + k_cont + k_mix + k_pois + k_nb</code> multivariate normal variables (<span class="math inline">\(X_{nxk}\)</span>) with correlation matrix <code>Sigma</code> are generated using singular value decomposition on a <span class="math inline">\(MVN_{nxk}(0,\ 1)\)</span> matrix and eigenvalue decomposition on <code>Sigma</code>.</p></li>
<li><p>The variables are generated from <span class="math inline">\(X_{nxk}\)</span> using the appropriate transformations (see <a href="variable_types.html">Variable Types</a> vignette).</p></li>
<li><p>The final correlation matrix is calculated, and the maximum error (<code>maxerr</code>) from the target correlation matrix is found.</p></li>
<li><p>If the error loop is specified (<code>error_loop</code> = TRUE), it is used on each variable pair to correct the final correlation until it is within <code>epsilon</code> of the target correlation or the maximum number of iterations <code>maxit</code> has been reached.</p></li>
<li><p>If continuous mixture variables are desired, these are created from the component variables.</p></li>
</ol>
</div>
</div>
<div id="overview-of-correlation-method-2" class="section level2">
<h2>Overview of Correlation Method 2:</h2>
<p>The intermediate correlations used in correlation method 2 are less simulation based than those in correlation method 1. Their calculations involve greater utilization of correction loops which make iterative adjustments until a maximum error has been reached (if possible). In addition, method 2 differs from method 1 in the following ways:</p>
<ol style="list-style-type: decimal">
<li><p>The intermediate correlations involving <strong>count variables</strong> are based on the methods of Barbiero &amp; Ferrari <span class="citation">(2012; 2015)</span>. The Poisson or Negative Binomial support is made finite by removing a small user-specified value (i.e. <span class="math inline">\(0.0001\)</span>) from the total cumulative probability. This truncation factor may differ for each count variable (see <code>maxcount_support</code>). The count variables are subsequently treated as ordinal and intermediate correlations are calculated using the correction loop of <code>ord_norm</code>.</p></li>
<li><p>The <strong>continuous - count variable</strong> correlations are based on an extension of the method of <span class="citation">Demirtas, Hedeker, and Mermelstein (2012)</span>, and the count variables are treated as ordinal. The correction factor is the product of the power method correlation between the continuous variable and the normal variable used to generate it <span class="citation">(Headrick and Kowalchuk 2007)</span> and the point-polyserial correlation between the ordinalized count variable and the normal variable used to generate it <span class="citation">(Olsson, Drasgow, and Dorans 1982)</span>. The intermediate correlations are the ratio of the target correlations to the correction factor.</p>
<ol style="list-style-type: lower-alpha">
<li><em>Poisson variables:</em> <code>intercorr_cont_pois2</code> is called to calculate the intermediate correlations for all variables.</li>
<li><em>Negative Binomial variables:</em> <code>intercorr_cont_nb2</code> is called to calculate the intermediate correlations for all variables.</li>
</ol></li>
</ol>
<div id="simulation-process-1" class="section level3">
<h3>Simulation Process:</h3>
<p>The algorithm used in the simulation function <code>corrvar2</code> that employs correlation method 2 is similar to that described for <code>corrvar</code>, with a few modifications:</p>
<ol style="list-style-type: decimal">
<li><p>The feasibility of <code>rho</code>, given the distribution parameters, should be checked first using the function <code>validcorr2</code>, which checks if <code>rho</code> is within the feasible bounds and returns the lower and upper correlation limits.</p></li>
<li><p>After the support is created for the ordinal variables (if no support is provided), the maximum support for the count variables is determined using <code>maxcount_support</code>, given truncation value vector <code>pois_eps</code> for Poisson variables and/or <code>nb_eps</code> for Negative Binomial variables. The cumulative probability truncation value may differ by variable, but a good value is <span class="math inline">\(0.0001\)</span>. The resulting supports and distribution parameters are used to create marginal lists, consisting of the cumulative probabilities for each count variable.</p></li>
<li><p>The intermediate correlation matrix <code>Sigma</code> is calculated using <code>intercorr2</code>.</p></li>
</ol>
</div>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<script type="text/x-mathjax-config">
   MathJax.Hub.Config({  "HTML-CSS": { minScaleAdjust: 115, availableFonts: [] }  });
</script>
<div id="refs" class="references">
<div id="ref-AmaDem">
<p>Amatya, A, and H Demirtas. 2015. “Simultaneous Generation of Multivariate Mixed Data with Poisson and Normal Marginals.” <em>Journal of Statistical Computation and Simulation</em> 85 (15): 3129–39. doi:<a href="https://doi.org/10.1080/00949655.2014.953534">10.1080/00949655.2014.953534</a>.</p>
</div>
<div id="ref-FerrBarb_Pois">
<p>Barbiero, A, and P A Ferrari. 2015. “Simulation of Correlated Poisson Variables.” <em>Applied Stochastic Models in Business and Industry</em> 31: 669–80. doi:<a href="https://doi.org/10.1002/asmb.2072">10.1002/asmb.2072</a>.</p>
</div>
<div id="ref-Matrix">
<p>Bates, D, and M Maechler. 2017. <em>Matrix: Sparse and Dense Matrix Classes and Methods</em>. <a href="https://CRAN.R-project.org/package=Matrix" class="uri">https://CRAN.R-project.org/package=Matrix</a>.</p>
</div>
<div id="ref-DemHed">
<p>Demirtas, H, and D Hedeker. 2011. “A Practical Way for Computing Approximate Lower and Upper Correlation Bounds.” <em>The American Statistician</em> 65 (2): 104–9. doi:<a href="https://doi.org/10.1198/tast.2011.10090">10.1198/tast.2011.10090</a>.</p>
</div>
<div id="ref-Dem_Power">
<p>Demirtas, H, D Hedeker, and R J Mermelstein. 2012. “Simulation of Massive Public Health Data by Power Polynomials.” <em>Statistics in Medicine</em> 31 (27): 3337–46. doi:<a href="https://doi.org/10.1002/sim.5362">10.1002/sim.5362</a>.</p>
</div>
<div id="ref-EmPied">
<p>Emrich, L J, and M R Piedmonte. 1991. “A Method for Generating High-Dimensional Multivariate Binary Variates.” <em>The American Statistician</em> 45: 302–4. doi:<a href="https://doi.org/10.1080/00031305.1991.10475828">10.1080/00031305.1991.10475828</a>.</p>
</div>
<div id="ref-FerrBarb_Ord">
<p>Ferrari, P A, and A Barbiero. 2012. “Simulating Ordinal Data.” <em>Multivariate Behavioral Research</em> 47 (4): 566–89. doi:<a href="https://doi.org/10.1080/00273171.2012.692630">10.1080/00273171.2012.692630</a>.</p>
</div>
<div id="ref-SMCD">
<p>Fialkowski, A C. 2017. <em>SimMultiCorrData: Simulation of Correlated Data with Multiple Variable Types</em>. <a href="https://CRAN.R-project.org/package=SimMultiCorrData" class="uri">https://CRAN.R-project.org/package=SimMultiCorrData</a>.</p>
</div>
<div id="ref-Fleish">
<p>Fleishman, A I. 1978. “A Method for Simulating Non-Normal Distributions.” <em>Psychometrika</em> 43: 521–32. doi:<a href="https://doi.org/10.1007/BF02293811">10.1007/BF02293811</a>.</p>
</div>
<div id="ref-Frech">
<p>Fréchet, M. 1957. “Les Tableaux de Corrélation et Les Programmes Linéaires.” <em>Revue de L’Institut International de Statistique / Review of the International Statistical Institute</em> 25 (1/3): 23–40. doi:<a href="https://doi.org/10.2307/1401672">10.2307/1401672</a>.</p>
</div>
<div id="ref-Head2002">
<p>Headrick, T C. 2002. “Fast Fifth-Order Polynomial Transforms for Generating Univariate and Multivariate Non-Normal Distributions.” <em>Computational Statistics and Data Analysis</em> 40 (4): 685–711. doi:<a href="https://doi.org/10.1016/S0167-9473(02)00072-5">10.1016/S0167-9473(02)00072-5</a>.</p>
</div>
<div id="ref-HeadKow">
<p>Headrick, T C, and R K Kowalchuk. 2007. “The Power Method Transformation: Its Probability Density Function, Distribution Function, and Its Further Use for Fitting Data.” <em>Journal of Statistical Computation and Simulation</em> 77: 229–49. doi:<a href="https://doi.org/10.1080/10629360600605065">10.1080/10629360600605065</a>.</p>
</div>
<div id="ref-HeadSaw1">
<p>Headrick, T C, and S S Sawilowsky. 1999. “Simulating Correlated Non-Normal Distributions: Extending the Fleishman Power Method.” <em>Psychometrika</em> 64: 25–35. doi:<a href="https://doi.org/10.1007/BF02294317">10.1007/BF02294317</a>.</p>
</div>
<div id="ref-Higham">
<p>Higham, N. 2002. “Computing the Nearest Correlation Matrix - a Problem from Finance.” <em>IMA Journal of Numerical Analysis</em> 22 (3): 329–43. doi:<a href="https://doi.org/10.1093/imanum/22.3.329">10.1093/imanum/22.3.329</a>.</p>
</div>
<div id="ref-Hoeff">
<p>Hoeffding, W. 1994. “Scale-Invariant Correlation Theory.” In <em>The Collected Works of Wassily Hoeffding</em>, edited by N I Fisher and P K Sen, 57–107. Springer Series in Statistics (Perspectives in Statistics). New York: Springer-Verlag. doi:<a href="https://doi.org/10.1007/978-1-4612-0865-5_4">10.1007/978-1-4612-0865-5_4</a>.</p>
</div>
<div id="ref-BinNonNor">
<p>Inan, G, and H Demirtas. 2016. <em>BinNonNor: Data Generation with Binary and Continuous Non-Normal Components</em>. <a href="https://CRAN.R-project.org/package=BinNonNor" class="uri">https://CRAN.R-project.org/package=BinNonNor</a>.</p>
</div>
<div id="ref-PolyCorr">
<p>Olsson, U, F Drasgow, and N J Dorans. 1982. “The Polyserial Correlation Coefficient.” <em>Psychometrika</em> 47 (3): 337–47. doi:<a href="https://doi.org/10.1007/BF02294164">10.1007/BF02294164</a>.</p>
</div>
<div id="ref-YahShm">
<p>Yahav, I, and G Shmueli. 2012. “On Generating Multivariate Poisson Data in Management Science Applications.” <em>Applied Stochastic Models in Business and Industry</em> 28 (1): 91–102. doi:<a href="https://doi.org/10.1002/asmb.901">10.1002/asmb.901</a>.</p>
</div>
<div id="ref-VGAM">
<p>Yee, T W. 2017. <em>VGAM: Vector Generalized Linear and Additive Models</em>. <a href="https://CRAN.R-project.org/package=VGAM" class="uri">https://CRAN.R-project.org/package=VGAM</a>.</p>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
